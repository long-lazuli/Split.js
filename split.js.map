{"version":3,"file":"split.js","sources":["src/split.js"],"sourcesContent":["// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements, graceful fallback (IE8 is supported)\n// and very few assumptions about the user's page layout.\nconst global = window\nconst document = global.document\n\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nconst add = 'addEventListener'\nconst remove = 'removeEventListener'\nconst getBoundingClientRect = 'getBoundingClientRect'\n\nconst eDragTrigger = ['mousedown', 'touchstart']\nconst eDragStart = ['selectstart', 'dragstart']\nconst eDragMove = ['mousemove', 'touchmove']\nconst eDragStop = ['mouseup', 'touchend', 'touchcancel']\nconst HORIZONTAL = 'horizontal'\nconst NOOP = () => false\n\n// Figure out if we're in IE8 or not. IE8 will still render correctly,\n// but will be static instead of draggable.\nconst isIE8 = global.attachEvent && !global[add]\n\n// Polyfill for Math.sign\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\nMath.sign = Math.sign || (x => ((x > 0) - (x < 0)) || +x)\n\n// Helpers function determines which prefixes CSS props and CSS values needs.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nconst calc = `${['', '-webkit-', '-moz-', '-o-'].filter(prefix => {\n    const el = document.createElement('div')\n    el.style.cssText = `width:${prefix}calc(9px)`\n\n    return (!!el.style.length)\n}).shift()}calc`\n\nconst userSelect = `${['', '-webkit-', '-moz-', '-o-'].filter(prefix => {\n    const el = document.createElement('div')\n    el.style.cssText = `${prefix}user-select:none`\n\n    return (!!el.style.length)\n}).shift()}userSelect`\n\n// Helper functions checks argument's type\nconst isString = v => (typeof v === 'string' || v instanceof String)\nconst isArray = Array.isArray || (arg => Object.prototype.toString.call(arg) === '[object Array]')\nconst isNode = n => n instanceof Element\n\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nconst elementOrSelector = el => {\n    const node = isString(el) ? document.querySelector(el) : el\n    if (!isNode(node)) throw new Error(`No element found matching selector ${el}`)\n    return node\n}\n\n// Helper function gets a property from the properties object, with a default fallback\nconst getOption = (options, propName, def) => {\n    const value = options[propName]\n    if (value !== undefined) {\n        return value\n    }\n    return def\n}\n\nconst eventListeners = (els, operation, events, callback) => {\n    const elementsList = !isArray(els) ? [els] : els\n    const eventsList = !isArray(events) ? [events] : events\n\n    elementsList.forEach(el => {\n        eventsList.forEach(ev => el[operation](ev, callback))\n    })\n}\n\n// Default options\nconst defaultGutterFn = (i, gutterDirection) => {\n    const gut = document.createElement('div')\n    gut.className = `gutter gutter-${gutterDirection}`\n    return gut\n}\n\nconst defaultPaneStyleFn = (dim, size, gutSize) => {\n    const style = {}\n\n    if (!isString(size)) {\n        if (!isIE8) {\n            style[dim] = `${calc}(${size}% - ${gutSize}px)`\n        } else {\n            style[dim] = `${size}%`\n        }\n    } else {\n        style[dim] = size\n    }\n\n    return style\n}\n\nconst defaultGutterStyleFn = (dim, gutSize) => ({ [dim]: `${gutSize}px` })\n\n// The main function to initialize a split. Split.js thinks about each pair\n// of two panes as an independant pair. Dragging the gutter between two panes\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// Pair object is shaped like this:\n//\n// {\n//     a: Number (Pane index)\n//     b: Number (Pane index)\n//     g: Number ( dragging Gutter index)\n// }\n//\n// Pane object is shaped like this:\n//\n// {\n//     el: DOM element\n//     minSize: Number\n//     size: Number\n//     isFirst: Boolean\n//     isLast: Boolean\n//     isCollapsed: Boolean\n// }\n//\n// Gutter object is shaped like this:\n//\n// {\n//     el: DOM element\n//     draggingDir: number | null,\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object, a gutter, and special isFirst/isLast properties.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nconst Split = (ids, options = {}) => {\n    let dimension\n    let clientAxis\n    let startBound\n\n    const panes = []\n    const gutters = []\n    let eventStartOffset\n\n\n    // All DOM elements in the split should have a common parent. We can grab\n    // the first elements parent and hope users read the docs because the\n    // behavior will be whacky otherwise.\n    const parent = elementOrSelector(ids[0]).parentNode\n    const parentFlexDirection = global.getComputedStyle(parent).flexDirection\n    const isReverse = parentFlexDirection === 'row-reverse' || parentFlexDirection === 'column-reverse'\n\n    // Set default options.sizes to equal percentages of the parent pane.\n    const sizes = getOption(options, 'sizes') || ids.map(() => 100 / ids.length)\n\n    // Standardize minSize to an array if it isn't already. This allows minSize\n    // to be passed as a number.\n    const minSize = getOption(options, 'minSize', 100)\n    const minSizes = isArray(minSize) ? minSize : ids.map(() => minSize)\n    const gutterSize = getOption(options, 'gutterSize', 10)\n    const snapOffset = getOption(options, 'snapOffset', 30)\n    // const pushablePanes = getOption(options, 'pushablePanes', false)\n    const pushablePanes = false\n    const direction = getOption(options, 'direction', HORIZONTAL)\n    const cursor = getOption(options, 'cursor', direction === HORIZONTAL ? 'ew-resize' : 'ns-resize')\n    const paneStyle = getOption(options, 'elementStyle', defaultPaneStyleFn)\n    const gutterCreate = getOption(options, 'gutter', defaultGutterFn)\n    const gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn)\n\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    // A lot of the behavior in the rest of the library is paramatized down to\n    // rely on CSS strings and classes.\n    if (direction === HORIZONTAL) {\n        dimension = 'width'\n        clientAxis = 'clientX'\n        startBound = 'left'\n    } else if (direction === 'vertical') {\n        dimension = 'height'\n        clientAxis = 'clientY'\n        startBound = 'top'\n    }\n\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // Each helper is bound to a Gutter object that contains its metadata. This\n    // also makes it easy to store references to listeners that that will be\n    // added and removed.\n    //\n    // Even though there are no other functions contained in them, aliasing\n    // this to self saves 50 bytes or so since it's used so frequently.\n    //\n    // The Gutter object saves metadata like dragging state, startBound and\n    // event listener references.\n    function applyPaneSize ({ el, size, isFirst, isLast }) {\n        const gutSize = (isFirst || isLast) ? gutterSize / 2 : gutterSize\n\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\n        // by string, like '300px'. This is less than ideal, because it breaks\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n        // make sure you calculate the gutter size by hand.\n        const style = paneStyle(dimension, size, gutSize)\n\n        Object.keys(style).forEach(prop => {\n            el.style[prop] = style[prop]\n        })\n    }\n\n    function applyGutterSize ({ el, size }) {\n        const style = gutterStyle(dimension, size)\n\n        Object.keys(style).forEach(prop => {\n            el.style[prop] = style[prop]\n        })\n    }\n\n    function getEventOffset (e) {\n        return ('touches' in e ? e.touches[0] : e)[clientAxis]\n    }\n\n\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n    // which allows the viewport to be resized without additional logic.\n    // Element a's size is the same as offset. b's size is total size - a size.\n    // Both sizes are calculated from the initial parent percentage,\n    // then the gutter size is subtracted.\n    function adjust (offset) {\n        const a = panes[this.a]\n        const b = panes[this.b]\n        const percentage = a.size + b.size\n\n        a.size = (offset / this.size) * percentage\n        b.size = (percentage - ((offset / this.size) * percentage))\n\n        applyPaneSize(a)\n        applyPaneSize(b)\n    }\n\n    // Cache some important sizes when drag starts, so we don't have to do that\n    // continously:\n    //\n    // `size`: The total size of the pair. First pane + second pane + all gutters between.\n    // `start`: The leading side of the first pane.\n    //\n    // | <--                size                  --> |\n    // ------------------------------------------------\n    // |     a.gutterSize -> |||                      |\n    // |                     |||                      |\n    // |                     |||                      |\n    // |                     ||| <- b.gutterSize      |\n    // ------------------------------------------------\n    // | <- start                                     |\n    function calculateSizes () {\n        const a = panes[this.a]\n        const b = panes[this.b]\n        const aBounds = a.el[getBoundingClientRect]()\n        const bBounds = b.el[getBoundingClientRect]()\n\n        // Figure out the parent size minus padding.\n        this.size = aBounds[dimension] + gutterSize + bBounds[dimension]\n        this.start = aBounds[startBound]\n\n        a.isCollapsed = aBounds[dimension] <= gutterSize\n        b.isCollapsed = bBounds[dimension] <= gutterSize\n    }\n\n    // drag, where all the magic happens. The logic is really quite simple:\n    //\n    // 1. Ignore if the gutter is not dragging.\n    // 2. Get the offset of the event.\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\n    // 4. Actually adjust each pane in the pair to offset.\n    //\n    // ---------------------------------------------------------------------\n    // |    | <- a.minSize               ||              b.minSize -> |    |\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n    // |    |  |                         ||                        |  |    |\n    // |    |  |                         ||                        |  |    |\n    // ---------------------------------------------------------------------\n    // | <- this.start                                        this.size -> |\n    function drag (e) {\n        const g = gutters[this.g]\n        let a = panes[this.a]\n        let b = panes[this.b]\n\n        if (g.draggingDir === null) return\n\n        // Get the offset of the event from the first side of the\n        // pair `this.start`. Supports touch events, but not multitouch, so only the first\n        // finger `touches[0]` is counted.\n        const eventOffset = getEventOffset(e)\n        g.draggingDir = Math.sign(eventOffset - eventStartOffset)\n\n        let pairOffset = eventOffset - this.start\n\n        // If within snapOffset of min or max, set offset to min or max.\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n        // Include the appropriate gutter sizes to prevent overflows.\n        if (g.draggingDir < 1) {\n            let pairGutterSize = gutterSize / (a.isFirst ? 2 : 1)\n\n            if (pushablePanes) {\n                while (!a.isFirst && eventOffset < (this.start + a.minSize)) {\n                    pairGutterSize = gutterSize / (a.isFirst ? 2 : 1)\n                    adjust.call(this, pairGutterSize)\n\n                    a = panes[this.a -= 1]\n                    calculateSizes.call(this)\n                    pairOffset = eventOffset - this.start\n                }\n            }\n\n            if (pairOffset <= a.minSize + snapOffset + pairGutterSize) {\n                pairOffset = a.isCollapsed ? pairGutterSize : a.minSize + pairGutterSize\n            }\n        }\n\n        if (g.draggingDir > -1) {\n            let pairGutterSize = this.size - (gutterSize / (b.isLast ? 2 : 1))\n\n            if (pushablePanes) {\n                while (!b.isLast && pairOffset > (this.size - b.minSize)) {\n                    pairGutterSize = this.size - (gutterSize / (b.isLast ? 2 : 1))\n                    adjust.call(this, pairGutterSize)\n\n                    b = panes[this.b += 1]\n                    calculateSizes.call(this)\n                }\n            }\n\n            if (pairOffset >= this.size - (b.minSize + snapOffset + gutterSize)) {\n                pairOffset = this.size - (b.isCollapsed ? gutterSize : b.minSize + gutterSize)\n            }\n        }\n\n        // Actually adjust the dragged pair size.\n        adjust.call(this, pairOffset)\n\n        // Call the drag callback continously. Don't do anything too intensive\n        // in this callback.\n        getOption(options, 'onDrag', NOOP)()\n    }\n\n    // stopDragging is very similar to startDragging in reverse.\n    function stopDragging () {\n        const g = gutters[this.g]\n        const a = panes[isReverse ? this.g + 1 : this.g]\n        const b = panes[isReverse ? this.g : this.g + 1]\n\n        if (g.draggingDir !== null) {\n            getOption(options, 'onDragEnd', NOOP)()\n        }\n\n        g.draggingDir = null\n        eventStartOffset = null\n\n        // Remove the stored event listeners. This is why we store them.\n        eventListeners(global, remove, eDragStop, g.stop)\n        eventListeners(global, remove, eDragMove, g.move)\n\n        // Clear bound function references\n        g.stop = null\n        g.move = null\n        g.el.style.cursor = ''\n\n        eventListeners([a.el, b.el], remove, eDragStart, NOOP)\n\n        a.el.style[userSelect] = ''\n        b.el.style[userSelect] = ''\n\n        parent.style.cursor = ''\n        document.body.style.cursor = ''\n    }\n\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\n    // It also adds event listeners for mouse/touch events,\n    // and prevents selection while dragging so avoid the selecting text.\n    function startDragging (e) {\n        // Don't actually drag the pane. We emulate that in the drag function.\n        e.preventDefault()\n\n        this.a = isReverse ? this.g + 1 : this.g\n        this.b = isReverse ? this.g : this.g + 1\n        calculateSizes.call(this)\n\n        // Alias frequently used variables to save space. 200 bytes.\n        const a = panes[isReverse ? this.b : this.a]\n        const b = panes[isReverse ? this.a : this.b]\n        const g = gutters[this.g]\n\n        // Call the onDragStart callback.\n        if (g.draggingDir === null) {\n            getOption(options, 'onDragStart', NOOP)()\n        }\n\n        // Set the dragging property of the pair object.\n        g.draggingDir = 0\n        eventStartOffset = getEventOffset(e)\n\n        // Create two event listeners bound to the same gutter object and store\n        // them in the gutter object.\n        g.move = drag.bind(this)\n        g.stop = stopDragging.bind(this)\n        g.el.style.cursor = cursor\n\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        eventListeners(global, add, eDragStop, g.stop)\n        eventListeners(global, add, eDragMove, g.move)\n\n        eventListeners([a.el, b.el], add, eDragStart, NOOP)\n\n        a.el.style[userSelect] = 'none'\n        b.el.style[userSelect] = 'none'\n\n        // Set the cursor at multiple levels\n        parent.style.cursor = cursor\n        document.body.style.cursor = cursor\n    }\n\n    // 5. Create Pane and Gutter objects. Each pair has an index reference to\n    // gutter `g`, panes `a` and `b` of the pair (left and right panes).\n    // Loop through the ids while creating panes & gutters.\n    // Every pane gets isFirst/isLast properties, as well as isCollapsed.\n    //\n    // Basic logic:\n    //\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n    // - Create gutter elements and add event listeners.\n    // - Set the size of the panes, minus the gutter sizes.\n    //\n    // -----------------------------------------------------------------------\n    // | Pane 0      | Pane 1              | Pane 2           | Pane 3       |\n    // |  .isFirst   |                     |                  |  .isLast     |\n    // |          Gutter 0              Gutter 1           Gutter 2          |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    ids.forEach((id, i) => {\n        const isFirstPane = (i === 0)\n        const isLastPane = (i === ids.length - 1)\n\n        const pane = {\n            // Create the element object.\n            i,\n            el: elementOrSelector(id),\n            minSize: minSizes[i],\n            size: sizes[i],\n\n            isFirst: isFirstPane,\n            isLast: isLastPane,\n            isCollapsed: false,\n        }\n\n        // Create gutter elements for each pair, if IE9 and above\n        if (!isFirstPane && !isIE8) {\n            const gutterIndex = gutters.length\n            const gutterElement = gutterCreate(gutterIndex, direction)\n            const gutter = {\n                i,\n                el: gutterElement,\n                size: gutterSize,\n                draggingDir: null,\n            }\n            applyGutterSize(gutter)\n\n            eventListeners(gutterElement, add, eDragTrigger, startDragging.bind({ g: gutterIndex }))\n\n            parent.insertBefore(gutterElement, pane.el)\n\n            gutters.push(gutter)\n        }\n\n        // Determine the size of the current pane. IE8 is supported by\n        // staticly assigning sizes without draggable gutters. Assigns a string\n        // to `size`.\n        applyPaneSize(pane)\n\n        const computedSize = pane.el[getBoundingClientRect]()[dimension]\n\n        if (computedSize < pane.minSize) {\n            pane.minSize = computedSize\n            applyPaneSize(pane)\n        }\n\n        panes.push(pane)\n    })\n\n    function setSizes (newSizes) {\n        newSizes.forEach((newSize, i) => {\n            panes[i].size = newSize\n            applyPaneSize(panes[i])\n        })\n    }\n\n    function getSizes () {\n        return panes.map(pane => pane.size)\n    }\n\n    function destroy () {\n        gutters.forEach(g => {\n            parent.removeChild(g)\n        })\n        panes.forEach(p => {\n            p.el.style[dimension] = ''\n        })\n    }\n\n    function collapse (i) {\n        const p = panes[i]\n\n        const pair = {\n            g: i,\n            a: p.isLast ? i - 1 : i,\n            b: p.isLast ? i : i + 1,\n        }\n\n        calculateSizes.call(pair)\n\n        let offset\n        if (p.isLast) {\n            offset = pair.size - (gutterSize / 2)\n        } else {\n            offset = gutterSize / (p.isFirst ? 2 : 1)\n        }\n\n        if (!isIE8) adjust.call(pair, offset)\n    }\n\n    return (isIE8) ? {\n        setSizes,\n        destroy,\n    } : {\n        setSizes,\n        getSizes,\n        collapse,\n        destroy,\n        parent,\n    }\n}\n\nexport default Split\n"],"names":["const","let","this","pairGutterSize"],"mappings":"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"}