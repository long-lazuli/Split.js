{"version":3,"file":"split.js","sources":["src/split.js"],"sourcesContent":["// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements, graceful fallback (IE8 is supported)\n// and very few assumptions about the user's page layout.\nconst global = window\nconst document = global.document\n\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nconst addEventListener = 'addEventListener'\nconst removeEventListener = 'removeEventListener'\nconst getBoundingClientRect = 'getBoundingClientRect'\nconst HORIZONTAL = 'horizontal'\nconst NOOP = () => false\n\n// Figure out if we're in IE8 or not. IE8 will still render correctly,\n// but will be static instead of draggable.\nconst isIE8 = global.attachEvent && !global[addEventListener]\n\n// Helper function determines which prefixes of CSS calc we need.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nconst calc = `${['', '-webkit-', '-moz-', '-o-'].filter(prefix => {\n    const el = document.createElement('div')\n    el.style.cssText = `width:${prefix}calc(9px)`\n\n    return (!!el.style.length)\n}).shift()}calc`\n\n// Helper function checks if its argument is a string-like type\nconst isString = v => (typeof v === 'string' || v instanceof String)\n\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nconst elementOrSelector = el => (isString(el) ? document.querySelector(el) : el)\n\n// Helper function gets a property from the properties object, with a default fallback\nconst getOption = (options, propName, def) => {\n    const value = options[propName]\n    if (value !== undefined) {\n        return value\n    }\n    return def\n}\n\n// Default options\nconst defaultGutterFn = (i, gutterDirection) => {\n    const gut = document.createElement('div')\n    gut.className = `gutter gutter-${gutterDirection}`\n    return gut\n}\n\nconst defaultElementStyleFn = (dim, size, gutSize) => {\n    const style = {}\n\n    if (!isString(size)) {\n        if (!isIE8) {\n            style[dim] = `${calc}(${size}% - ${gutSize}px)`\n        } else {\n            style[dim] = `${size}%`\n        }\n    } else {\n        style[dim] = size\n    }\n\n    return style\n}\n\nconst defaultGutterStyleFn = (dim, gutSize) => ({ [dim]: `${gutSize}px` })\n\n// The main function to initialize a split. Split.js thinks about each pair\n// of two panes as an independant pair. Dragging the gutter between two panes\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// Pair object is shaped like this:\n//\n// {\n//     a: Number (Pane index)\n//     b: Number (Pane index)\n//     d: Number ( dragging Gutter index)\n// }\n//\n// Pane object is shaped like this:\n//\n// {\n//     el: DOM element\n//     minSize: Number\n//     size: Number\n//     isFirst: Boolean\n//     isLast: Boolean\n//     isCollapsed: Boolean\n// }\n//\n// Gutter object is shaped like this:\n//\n// {\n//     el: DOM element\n//     isDragging: Boolean,\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object, a gutter, and special isFirst/isLast properties.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nconst Split = (ids, options = {}) => {\n    let dimension\n    let clientAxis\n    let position\n    let panes\n    const gutters = []\n    let draggingGutter = null\n\n    // All DOM elements in the split should have a common parent. We can grab\n    // the first elements parent and hope users read the docs because the\n    // behavior will be whacky otherwise.\n    const parent = elementOrSelector(ids[0]).parentNode\n    // const parentFlexDirection = global.getComputedStyle(parent).flexDirection\n\n    // Set default options.sizes to equal percentages of the parent pane.\n    const sizes = getOption(options, 'sizes') || ids.map(() => 100 / ids.length)\n\n    // Standardize minSize to an array if it isn't already. This allows minSize\n    // to be passed as a number.\n    const minSize = getOption(options, 'minSize', 100)\n    const minSizes = Array.isArray(minSize) ? minSize : ids.map(() => minSize)\n    const gutterSize = getOption(options, 'gutterSize', 10)\n    const snapOffset = getOption(options, 'snapOffset', 30)\n    const pushablePanes = getOption(options, 'pushablePanes', false)\n    const direction = getOption(options, 'direction', HORIZONTAL)\n    const cursor = getOption(options, 'cursor', direction === HORIZONTAL ? 'ew-resize' : 'ns-resize')\n    const gutterCreate = getOption(options, 'gutter', defaultGutterFn)\n    const elementStyle = getOption(options, 'elementStyle', defaultElementStyleFn)\n    const gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn)\n\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    // A lot of the behavior in the rest of the library is paramatized down to\n    // rely on CSS strings and classes.\n    if (direction === HORIZONTAL) {\n        dimension = 'width'\n        clientAxis = 'clientX'\n        position = 'left'\n    } else if (direction === 'vertical') {\n        dimension = 'height'\n        clientAxis = 'clientY'\n        position = 'top'\n    }\n\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // Each helper is bound to a Gutter object that contains its metadata. This\n    // also makes it easy to store references to listeners that that will be\n    // added and removed.\n    //\n    // Even though there are no other functions contained in them, aliasing\n    // this to self saves 50 bytes or so since it's used so frequently.\n    //\n    // The Gutter object saves metadata like dragging state, position and\n    // event listener references.\n\n    function applyPaneSize ({ el, size, isFirst, isLast }) {\n        const gutSize = isFirst || isLast ? gutterSize / 2 : gutterSize\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\n        // by string, like '300px'. This is less than ideal, because it breaks\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n        // make sure you calculate the gutter size by hand.\n        const style = elementStyle(dimension, size, gutSize)\n\n        // eslint-disable-next-line no-param-reassign\n        Object.keys(style).forEach(prop => {\n            el.style[prop] = style[prop]\n        })\n    }\n\n    function setGutterSize (gutterElement, gutSize) {\n        const style = gutterStyle(dimension, gutSize)\n\n        // eslint-disable-next-line no-param-reassign\n        Object.keys(style).forEach(prop => {\n            gutterElement.style[prop] = style[prop]\n        })\n    }\n\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n    // which allows the viewport to be resized without additional logic.\n    // Element a's size is the same as offset. b's size is total size - a size.\n    // Both sizes are calculated from the initial parent percentage,\n    // then the gutter size is subtracted.\n    function adjust (offset) {\n        const a = panes[this.a]\n        const b = panes[this.b]\n        const percentage = a.size + b.size\n\n        a.size = (offset / this.size) * percentage\n        b.size = (percentage - ((offset / this.size) * percentage))\n\n        applyPaneSize(a)\n        applyPaneSize(b)\n    }\n\n    // Cache some important sizes when drag starts, so we don't have to do that\n    // continously:\n    //\n    // `size`: The total size of the pair. First + second + first gutter + second gutter.\n    // `start`: The leading side of the first pane.\n    //\n    // ------------------------------------------------\n    // |     a.gutterSize -> |||                      |\n    // |                     |||                      |\n    // |                     |||                      |\n    // |                     ||| <- b.gutterSize      |\n    // ------------------------------------------------\n    // | <- start                             size -> |\n    function calculateSizes () {\n        // Figure out the parent size minus padding.\n        const a = panes[this.a]\n        const b = panes[this.b]\n        const gutWidth = gutters.slice(this.a, this.b).reduce((S, { size }) => S + size, 0)\n\n        const aBounds = a.el[getBoundingClientRect]()\n        const bBounds = b.el[getBoundingClientRect]()\n\n        this.size = aBounds[dimension] + bBounds[dimension] + gutWidth\n        this.start = aBounds[position]\n    }\n\n    // drag, where all the magic happens. The logic is really quite simple:\n    //\n    // 1. Ignore if the gutter is not dragging.\n    // 2. Get the offset of the event.\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\n    // 4. Actually adjust each pane in the pair to offset.\n    //\n    // ---------------------------------------------------------------------\n    // |    | <- a.minSize               ||              b.minSize -> |    |\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n    // |    |  |                         ||                        |  |    |\n    // |    |  |                         ||                        |  |    |\n    // ---------------------------------------------------------------------\n    // | <- this.start                                        this.size -> |\n    function drag (e) {\n        const pair = {\n            a: this.gutterIndex,\n            b: this.gutterIndex + 1,\n        }\n        let a = panes[pair.a]\n        let b = panes[pair.b]\n\n        if (draggingGutter === null) return\n\n        let eventOffset\n        // Get the offset of the event from the first side of the\n        // pair `this.start`. Supports touch events, but not multitouch, so only the first\n        // finger `touches[0]` is counted.\n        if ('touches' in e) {\n            eventOffset = e.touches[0][clientAxis] - pair.start\n        } else {\n            eventOffset = e[clientAxis] - pair.start\n        }\n\n        let pairOffset = eventOffset\n\n        if (pushablePanes) {\n            let pushedPair\n\n            while (!a.isFirst && eventOffset < (a.start + a.minSize)) {\n                pair.a -= 1\n                if (!pushedPair.size) calculateSizes.call(pushedPair)\n                pairOffset += pair.start - pushedPair.start - a.minSize\n            }\n\n            while (!b.isLast && eventOffset > (pair.size - b.minSize)) {\n                pair.b += 1\n                if (!pushedPair.size) calculateSizes.call(pushedPair)\n            }\n\n            calculateSizes.call(pair)\n\n            a = panes[pair.a]\n            b = panes[pair.b]\n        }\n\n        // If within snapOffset of min or max, set offset to min or max.\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n        // Include the appropriate gutter sizes to prevent overflows.\n        if (pairOffset <= a.minSize + snapOffset + panes[pair.a].gutterSize) {\n            pairOffset = a.minSize + panes[pair.a].gutterSize\n        } else if (pairOffset >= pair.size - (b.minSize + snapOffset + panes[pair.b].gutterSize)) {\n            pairOffset = pair.size - (b.minSize + panes[pair.b].gutterSize)\n        }\n\n        // Actually adjust the dragged pair size.\n        adjust.call(pair, pairOffset)\n\n        // Call the drag callback continously. Don't do anything too intensive\n        // in this callback.\n        getOption(options, 'onDrag', NOOP)()\n    }\n\n    // stopDragging is very similar to startDragging in reverse.\n    function stopDragging () {\n        const gutter = gutters[this.gutterIndex]\n        const a = panes[this.gutterIndex]\n        const b = panes[this.gutterIndex + 1]\n\n        if (draggingGutter !== null) {\n            getOption(options, 'onDragEnd', NOOP)()\n        }\n\n        gutter.isDragging = false\n\n        // Remove the stored event listeners. This is why we store them.\n        global[removeEventListener]('mouseup', gutter.stop)\n        global[removeEventListener]('touchend', gutter.stop)\n        global[removeEventListener]('touchcancel', gutter.stop)\n        global[removeEventListener]('mousemove', gutter.move)\n        global[removeEventListener]('touchmove', gutter.move)\n\n        // Clear bound function references\n        gutter.stop = null\n        gutter.move = null\n\n        a.el[removeEventListener]('selectstart', NOOP)\n        a.el[removeEventListener]('dragstart', NOOP)\n        b.el[removeEventListener]('selectstart', NOOP)\n        b.el[removeEventListener]('dragstart', NOOP)\n\n        a.el.style.userSelect = ''\n        a.el.style.webkitUserSelect = ''\n        a.el.style.MozUserSelect = ''\n        a.el.style.pointerEvents = ''\n\n        b.el.style.userSelect = ''\n        b.el.style.webkitUserSelect = ''\n        b.el.style.MozUserSelect = ''\n        b.el.style.pointerEvents = ''\n\n        gutter.el.style.cursor = ''\n        parent.style.cursor = ''\n        document.body.style.cursor = ''\n    }\n\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\n    // It also adds event listeners for mouse/touch events,\n    // and prevents selection while dragging so avoid the selecting text.\n    function startDragging (e) {\n        // Alias frequently used variables to save space. 200 bytes.\n        const gutter = gutters[this.gutterIndex]\n        const a = panes[this.gutterIndex]\n        const b = panes[this.gutterIndex + 1]\n\n        // Call the onDragStart callback.\n        if (draggingGutter === null) {\n            getOption(options, 'onDragStart', NOOP)()\n        }\n\n        // Don't actually drag the pane. We emulate that in the drag function.\n        e.preventDefault()\n\n        // Set the dragging property of the pair object.\n        draggingGutter = gutter\n\n        // Create two event listeners bound to the same gutter object and store\n        // them in the gutter object.\n        gutter.move = drag.bind(this)\n        gutter.stop = stopDragging.bind(this)\n\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        global[addEventListener]('mouseup', gutter.stop)\n        global[addEventListener]('touchend', gutter.stop)\n        global[addEventListener]('touchcancel', gutter.stop)\n        global[addEventListener]('mousemove', gutter.move)\n        global[addEventListener]('touchmove', gutter.move)\n\n        // Disable selection. Disable!\n        a.el[addEventListener]('selectstart', NOOP)\n        a.el[addEventListener]('dragstart', NOOP)\n        b.el[addEventListener]('selectstart', NOOP)\n        b.el[addEventListener]('dragstart', NOOP)\n\n        a.el.style.userSelect = 'none'\n        a.el.style.webkitUserSelect = 'none'\n        a.el.style.MozUserSelect = 'none'\n        a.el.style.pointerEvents = 'none'\n\n        b.el.style.userSelect = 'none'\n        b.el.style.webkitUserSelect = 'none'\n        b.el.style.MozUserSelect = 'none'\n        b.el.style.pointerEvents = 'none'\n\n        // Set the cursor at multiple levels\n        gutter.el.style.cursor = cursor\n        parent.style.cursor = cursor\n        document.body.style.cursor = cursor\n\n        calculateSizes.call(gutter)\n    }\n\n    // 5. Create pair from pane objects. Each pair has an index reference to\n    // panes `a` and `b` of the pair (first and second panes).\n    // Loop through the panes while pairing them off. Every pair gets a\n    // `pair` object, a gutter, and isFirst/isLast properties.\n    //\n    // Basic logic:\n    //\n    // - Starting with the second pane `i > 0`, create `pair` objects with\n    //   `a = i - 1` and `b = i`\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n    // - Create gutter elements and add event listeners.\n    // - Set the size of the panes, minus the gutter sizes.\n    //\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |       isFirst       |                  |     isLast   |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    panes = ids.map((id, i) => {\n        // Create the element object.\n\n        const isFirstPane = (i === 0)\n        const isLastPane = (i === ids.length - 1)\n\n        const pane = {\n            el: elementOrSelector(id),\n            minSize: minSizes[i],\n            size: sizes[i],\n            isFirst: isFirstPane,\n            isLast: isLastPane,\n            isCollapsed: false,\n        }\n\n        // Determine the size of the current pane. IE8 is supported by\n        // staticly assigning sizes without draggable gutters. Assigns a string\n        // to `size`.\n        //\n        // Create gutter elements for each pair, if IE9 and above\n        if (i > 0 && !isIE8) {\n            const gutterIndex = gutters.length\n            const gutterElement = gutterCreate(gutterIndex, direction)\n            setGutterSize(gutterElement, gutterSize)\n\n            gutterElement[addEventListener]('mousedown', startDragging.bind({ gutterIndex }))\n            gutterElement[addEventListener]('touchstart', startDragging.bind({ gutterIndex }))\n\n            parent.insertBefore(gutterElement, pane.el)\n\n            gutters.push({\n                el: gutterElement,\n            })\n        }\n\n        applyPaneSize(pane)\n\n        const computedSize = pane.el[getBoundingClientRect]()[dimension]\n\n        if (computedSize < pane.minSize) {\n            pane.minSize = computedSize\n        }\n\n        return pane\n    })\n\n    // function selectPair(a, b) {\n    //     // if the parent has a reverse flex-direction, switch the pair elements.\n    //     const isReverse = (\n    //         parentFlexDirection === 'row-reverse'\n    //      || parentFlexDirection === 'column-reverse'\n    //     )\n    //\n    //     const pair = {\n    //         a: isReverse ? b : a,\n    //         b: isReverse ? a : b,\n    //         dragging: false,\n    //     }\n    //\n    //     return pair\n    // }\n\n    function setSizes (newSizes) {\n        newSizes.forEach((newSize, i) => {\n            panes[i].size = newSize\n            applyPaneSize(panes[i])\n        })\n    }\n\n    function destroy () {\n        gutters.forEach(g => {\n            parent.removeChild(g)\n        })\n        panes.forEach(p => {\n            p.el.style[dimension] = ''\n        })\n    }\n\n    if (isIE8) {\n        return {\n            setSizes,\n            destroy,\n        }\n    }\n\n    return {\n        setSizes,\n        getSizes () {\n            return panes.map(pane => pane.size)\n        },\n        collapse (i) {\n            const pair = {\n                a: i === panes.length ? i - 1 : i,\n                b: i === panes.length ? i : i + 1,\n            }\n\n            calculateSizes.call(pair)\n\n            if (!isIE8) {\n                adjust.call(pair)\n            }\n        },\n        destroy,\n        parent,\n    }\n}\n\nexport default Split\n"],"names":["const","let"],"mappings":"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"}