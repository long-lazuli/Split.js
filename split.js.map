{"version":3,"file":"split.js","sources":["src/split.js"],"sourcesContent":["// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements, graceful fallback (IE8 is supported)\n// and very few assumptions about the user's page layout.\nconst global = window\nconst document = global.document\n\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nconst add = 'addEventListener'\nconst remove = 'removeEventListener'\nconst getBoundingClientRect = 'getBoundingClientRect'\n\nconst eDragTrigger = ['mousedown', 'touchstart']\nconst eDragStart = ['selectstart', 'dragstart']\nconst eDragMove = ['mousemove', 'touchmove']\nconst eDragStop = ['mouseup', 'touchend', 'touchcancel']\n\nconst HORIZONTAL = 'horizontal'\nconst NOOP = () => false\n\n// Figure out if we're in IE8 or not. IE8 will still render correctly,\n// but will be static instead of draggable.\nconst isIE8 = global.attachEvent && !global[add]\n\n// Helpers function determines which prefixes CSS props and CSS values needs.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nconst calc = `${['', '-webkit-', '-moz-', '-o-'].filter(prefix => {\n    const el = document.createElement('div')\n    el.style.cssText = `width:${prefix}calc(9px)`\n\n    return (!!el.style.length)\n}).shift()}calc`\n\nconst userSelect = `${['', '-webkit-', '-moz-', '-o-'].filter(prefix => {\n    const el = document.createElement('div')\n    el.style.cssText = `${prefix}user-select: none`\n\n    return (!!el.style.length)\n}).shift()}userSelect`\n\n// Helper function checks if its argument is a string-like type\nconst isString = v => (typeof v === 'string' || v instanceof String)\nconst isArray = Array.isArray || (arg => Object.prototype.toString.call(arg) === '[object Array]')\n\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nconst elementOrSelector = el => (isString(el) ? document.querySelector(el) : el)\n\n// Helper function gets a property from the properties object, with a default fallback\nconst getOption = (options, propName, def) => {\n    const value = options[propName]\n    if (value !== undefined) {\n        return value\n    }\n    return def\n}\n\nconst eventListeners = (els, operation, events, callback) => {\n    const elArr = !isArray(els) ? [els] : els\n    const eArr = !isArray(events) ? [events] : events\n\n    elArr.forEach(el => {\n        eArr.forEach(eName => el[operation](eName, callback))\n    })\n}\n\n// Default options\nconst defaultGutterFn = (i, gutterDirection) => {\n    const gut = document.createElement('div')\n    gut.className = `gutter gutter-${gutterDirection}`\n    return gut\n}\n\nconst defaultElementStyleFn = (dim, size, gutSize) => {\n    const style = {}\n\n    if (!isString(size)) {\n        if (!isIE8) {\n            style[dim] = `${calc}(${size}% - ${gutSize}px)`\n        } else {\n            style[dim] = `${size}%`\n        }\n    } else {\n        style[dim] = size\n    }\n\n    return style\n}\n\nconst defaultGutterStyleFn = (dim, gutSize) => ({ [dim]: `${gutSize}px` })\n\n// The main function to initialize a split. Split.js thinks about each pair\n// of two panes as an independant pair. Dragging the gutter between two panes\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// Pair object is shaped like this:\n//\n// {\n//     a: Number (Pane index)\n//     b: Number (Pane index)\n//     g: Number ( dragging Gutter index)\n// }\n//\n// Pane object is shaped like this:\n//\n// {\n//     el: DOM element\n//     minSize: Number\n//     size: Number\n//     isFirst: Boolean\n//     isLast: Boolean\n//     isCollapsed: Boolean\n// }\n//\n// Gutter object is shaped like this:\n//\n// {\n//     el: DOM element\n//     isDragging: Boolean,\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object, a gutter, and special isFirst/isLast properties.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nconst Split = (ids, options = {}) => {\n    let dimension\n    let clientAxis\n    let position\n\n    const panes = []\n    const gutters = []\n\n    // All DOM elements in the split should have a common parent. We can grab\n    // the first elements parent and hope users read the docs because the\n    // behavior will be whacky otherwise.\n    const parent = elementOrSelector(ids[0]).parentNode\n    const parentFlexDirection = global.getComputedStyle(parent).flexDirection\n    const isReverse = parentFlexDirection === 'row-reverse' || parentFlexDirection === 'column-reverse'\n\n    // Set default options.sizes to equal percentages of the parent pane.\n    const sizes = getOption(options, 'sizes') || ids.map(() => 100 / ids.length)\n\n    // Standardize minSize to an array if it isn't already. This allows minSize\n    // to be passed as a number.\n    const minSize = getOption(options, 'minSize', 100)\n    const minSizes = isArray(minSize) ? minSize : ids.map(() => minSize)\n    const gutterSize = getOption(options, 'gutterSize', 10)\n    const snapOffset = getOption(options, 'snapOffset', 30)\n    const pushablePanes = getOption(options, 'pushablePanes', false)\n    const direction = getOption(options, 'direction', HORIZONTAL)\n    const cursor = getOption(options, 'cursor', direction === HORIZONTAL ? 'ew-resize' : 'ns-resize')\n    const gutterCreate = getOption(options, 'gutter', defaultGutterFn)\n    const elementStyle = getOption(options, 'elementStyle', defaultElementStyleFn)\n    const gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn)\n\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    // A lot of the behavior in the rest of the library is paramatized down to\n    // rely on CSS strings and classes.\n    if (direction === HORIZONTAL) {\n        dimension = 'width'\n        clientAxis = 'clientX'\n        position = 'left'\n    } else if (direction === 'vertical') {\n        dimension = 'height'\n        clientAxis = 'clientY'\n        position = 'top'\n    }\n\n    // const parentBounds = parent[getBoundingClientRect]()\n\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // Each helper is bound to a Gutter object that contains its metadata. This\n    // also makes it easy to store references to listeners that that will be\n    // added and removed.\n    //\n    // Even though there are no other functions contained in them, aliasing\n    // this to self saves 50 bytes or so since it's used so frequently.\n    //\n    // The Gutter object saves metadata like dragging state, position and\n    // event listener references.\n\n    function applyPaneSize ({ el, size, isFirst, isLast }) {\n        const gutSize = (isFirst || isLast) ? gutterSize / 2 : gutterSize\n\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\n        // by string, like '300px'. This is less than ideal, because it breaks\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n        // make sure you calculate the gutter size by hand.\n        const style = elementStyle(dimension, size, gutSize)\n\n        // eslint-disable-next-line no-param-reassign\n        Object.keys(style).forEach(prop => {\n            el.style[prop] = style[prop]\n        })\n    }\n\n    function applyGutterSize ({ el, size }) {\n        const style = gutterStyle(dimension, size)\n\n        // eslint-disable-next-line no-param-reassign\n        Object.keys(style).forEach(prop => {\n            el.style[prop] = style[prop]\n        })\n    }\n\n    function getSizeBetween (start, end) {\n        return panes.slice(start, end).reduce(S => S + gutterSize, 0)\n    }\n\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n    // which allows the viewport to be resized without additional logic.\n    // Element a's size is the same as offset. b's size is total size - a size.\n    // Both sizes are calculated from the initial parent percentage,\n    // then the gutter size is subtracted.\n    function adjust (offset) {\n        const a = panes[this.a]\n        const b = panes[this.b]\n        const percentage = a.size + b.size\n\n        a.size = (offset / this.size) * percentage\n        b.size = (percentage - ((offset / this.size) * percentage))\n\n        applyPaneSize(a)\n        applyPaneSize(b)\n    }\n\n    // Cache some important sizes when drag starts, so we don't have to do that\n    // continously:\n    //\n    // `size`: The total size of the pair. First pane + second pane + all gutters between.\n    // `start`: The leading side of the first pane.\n    //\n    // ------------------------------------------------\n    // |     a.gutterSize -> |||                      |\n    // |                     |||                      |\n    // |                     |||                      |\n    // |                     ||| <- b.gutterSize      |\n    // ------------------------------------------------\n    // | <- start                             size -> |\n    function calculateSizes () {\n        const aBounds = panes[this.a].el[getBoundingClientRect]()\n        const bBounds = panes[this.b].el[getBoundingClientRect]()\n        const allGuttersSize = getSizeBetween(this.a, this.b)\n\n        // Figure out the parent size minus padding.\n        this.size = aBounds[dimension] + allGuttersSize + bBounds[dimension]\n        this.start = aBounds[position]\n    }\n\n    // drag, where all the magic happens. The logic is really quite simple:\n    //\n    // 1. Ignore if the gutter is not dragging.\n    // 2. Get the offset of the event.\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\n    // 4. Actually adjust each pane in the pair to offset.\n    //\n    // ---------------------------------------------------------------------\n    // |    | <- a.minSize               ||              b.minSize -> |    |\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n    // |    |  |                         ||                        |  |    |\n    // |    |  |                         ||                        |  |    |\n    // ---------------------------------------------------------------------\n    // | <- this.start                                        this.size -> |\n    function drag (e) {\n        const g = gutters[this.g]\n        let a = panes[this.a]\n        let b = panes[this.b]\n\n        if (!g.isDragging) return\n\n        // Get the offset of the event from the first side of the\n        // pair `this.start`. Supports touch events, but not multitouch, so only the first\n        // finger `touches[0]` is counted.\n        const eventOffset = ('touches' in e ? e.touches[0] : e)[clientAxis]\n        let pairOffset = eventOffset - this.start\n\n        if (pushablePanes) {\n            while (!a.isFirst && eventOffset < (this.start + a.minSize)) {\n                this.a -= 1\n                calculateSizes.call(this)\n                pairOffset = eventOffset - this.start\n                a = panes[this.a]\n            }\n\n            while (!b.isLast && eventOffset > (this.size - b.minSize)) {\n                this.b += 1\n                calculateSizes.call(this)\n                b = panes[this.b]\n            }\n        }\n\n        // If within snapOffset of min or max, set offset to min or max.\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n        // Include the appropriate gutter sizes to prevent overflows.\n        if (pairOffset <= a.minSize + snapOffset + gutterSize) {\n            pairOffset = a.minSize + gutterSize\n        } else if (pairOffset >= this.size - (b.minSize + snapOffset + gutterSize)) {\n            pairOffset = this.size - (b.minSize + gutterSize)\n        }\n\n        // Actually adjust the dragged pair size.\n        adjust.call(this, pairOffset)\n\n        // Call the drag callback continously. Don't do anything too intensive\n        // in this callback.\n        getOption(options, 'onDrag', NOOP)()\n    }\n\n    // stopDragging is very similar to startDragging in reverse.\n    function stopDragging () {\n        const g = gutters[this.g]\n        const a = panes[isReverse ? this.g + 1 : this.g]\n        const b = panes[isReverse ? this.g : this.g + 1]\n\n        if (g.isDragging) {\n            getOption(options, 'onDragEnd', NOOP)()\n        }\n\n        g.isDragging = false\n\n        // Remove the stored event listeners. This is why we store them.\n        eventListeners(global, remove, eDragStop, g.stop)\n        eventListeners(global, remove, eDragMove, g.move)\n\n        // Clear bound function references\n        g.stop = null\n        g.move = null\n        g.el.style.cursor = ''\n\n        eventListeners([a.el, b.el], remove, eDragStart, NOOP)\n\n        a.el.style[userSelect] = ''\n        b.el.style[userSelect] = ''\n\n        parent.style.cursor = ''\n        document.body.style.cursor = ''\n    }\n\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\n    // It also adds event listeners for mouse/touch events,\n    // and prevents selection while dragging so avoid the selecting text.\n    function startDragging (e) {\n        // Don't actually drag the pane. We emulate that in the drag function.\n        e.preventDefault()\n\n        this.a = isReverse ? this.g + 1 : this.g\n        this.b = isReverse ? this.g : this.g + 1\n        calculateSizes.call(this)\n\n        // Alias frequently used variables to save space. 200 bytes.\n        const a = panes[isReverse ? this.b : this.a]\n        const b = panes[isReverse ? this.a : this.b]\n        const g = gutters[this.g]\n\n        // Call the onDragStart callback.\n        if (!g.isDragging) {\n            getOption(options, 'onDragStart', NOOP)()\n        }\n        // Set the dragging property of the pair object.\n        g.isDragging = true\n\n        // Create two event listeners bound to the same gutter object and store\n        // them in the gutter object.\n        g.move = drag.bind(this)\n        g.stop = stopDragging.bind(this)\n        g.el.style.cursor = cursor\n\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        eventListeners(global, add, eDragStop, g.stop)\n        eventListeners(global, add, eDragMove, g.move)\n\n        eventListeners([a.el, b.el], add, eDragStart, NOOP)\n\n        a.el.style[userSelect] = 'none'\n        b.el.style[userSelect] = 'none'\n\n        // Set the cursor at multiple levels\n        parent.style.cursor = cursor\n        document.body.style.cursor = cursor\n    }\n\n    // 5. Create Pane and Gutter objects. Each pair has an index reference to\n    // panes `a` and `b` of the pair (first and second panes).\n    // Loop through the panes while pairing them off. Every pair gets a\n    // `pair` object, a gutter, and isFirst/isLast properties.\n    //\n    // Basic logic:\n    //\n    // - Starting with the second pane `i > 0`, create `pair` objects with\n    //   `a = i - 1` and `b = i`\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n    // - Create gutter elements and add event listeners.\n    // - Set the size of the panes, minus the gutter sizes.\n    //\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |       isFirst       |                  |     isLast   |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    ids.forEach((id, i) => {\n        const isFirstPane = (i === 0)\n        const isLastPane = (i === ids.length - 1)\n\n        const pane = {\n            // Create the element object.\n            i,\n            el: elementOrSelector(id),\n            minSize: minSizes[i],\n            size: sizes[i],\n\n            isFirst: isFirstPane,\n            isLast: isLastPane,\n            isCollapsed: false,\n        }\n\n        // Create gutter elements for each pair, if IE9 and above\n        if (!isFirstPane && !isIE8) {\n            const gutterIndex = gutters.length\n            const gutterElement = gutterCreate(gutterIndex, direction)\n            const gutter = {\n                i,\n                el: gutterElement,\n                size: gutterSize,\n            }\n            applyGutterSize(gutter)\n\n            eventListeners(gutterElement, add, eDragTrigger, startDragging.bind({ g: gutterIndex }))\n\n            parent.insertBefore(gutterElement, pane.el)\n\n            gutters.push(gutter)\n        }\n\n        // Determine the size of the current pane. IE8 is supported by\n        // staticly assigning sizes without draggable gutters. Assigns a string\n        // to `size`.\n        applyPaneSize(pane)\n\n        const computedSize = pane.el[getBoundingClientRect]()[dimension]\n\n        if (computedSize < pane.minSize) {\n            pane.minSize = computedSize\n        }\n\n        applyPaneSize(pane)\n\n        panes.push(pane)\n    })\n\n    // function selectPair(a, b) {\n    //     // if the parent has a reverse flex-direction, switch the pair elements.\n    //     const isReverse = (\n    //         parentFlexDirection === 'row-reverse'\n    //      || parentFlexDirection === 'column-reverse'\n    //     )\n    //\n    //     const pair = {\n    //         a: isReverse ? b : a,\n    //         b: isReverse ? a : b,\n    //         dragging: false,\n    //     }\n    //\n    //     return pair\n    // }\n\n    function setSizes (newSizes) {\n        newSizes.forEach((newSize, i) => {\n            panes[i].size = newSize\n            applyPaneSize(panes[i])\n        })\n    }\n\n    function destroy () {\n        gutters.forEach(g => {\n            parent.removeChild(g)\n        })\n        panes.forEach(p => {\n            p.el.style[dimension] = ''\n        })\n    }\n\n    if (isIE8) {\n        return {\n            setSizes,\n            destroy,\n        }\n    }\n\n    return {\n        setSizes,\n        getSizes () {\n            return panes.map(pane => pane.size)\n        },\n        collapse (i) {\n            const isLast = i === panes.length - 1\n\n            const pair = {\n                g: i,\n                a: isLast ? i - 1 : i,\n                b: isLast ? i : i + 1,\n            }\n\n            calculateSizes.call(pair)\n\n            if (!isIE8) {\n                adjust.call(pair, isLast ? pair.size : 0)\n            }\n        },\n        destroy,\n        parent,\n    }\n}\n\nexport default Split\n"],"names":["const","let","this"],"mappings":"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"}